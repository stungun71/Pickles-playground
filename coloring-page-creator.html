<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo to Coloring Page</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 1200px;
            width: 100%;
        }

        .upload-section {
            text-align: center;
            padding: 40px;
            border: 3px dashed #667eea;
            border-radius: 15px;
            background: #f8f9ff;
            margin-bottom: 30px;
            transition: all 0.3s ease;
        }

        .upload-section:hover {
            background: #f0f2ff;
            border-color: #764ba2;
        }

        .upload-section h2 {
            color: #667eea;
            margin-bottom: 15px;
        }

        .upload-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 40px;
            border: none;
            border-radius: 50px;
            font-size: 1.1em;
            cursor: pointer;
            transition: transform 0.2s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        #fileInput {
            display: none;
        }

        .controls {
            display: none;
            margin-bottom: 20px;
        }

        .controls.active {
            display: block;
        }

        .control-row {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #f8f9ff;
            padding: 10px 20px;
            border-radius: 10px;
        }

        .control-group label {
            font-weight: 600;
            color: #667eea;
        }

        input[type="range"] {
            width: 150px;
        }

        input[type="color"] {
            width: 60px;
            height: 40px;
            border: 3px solid #667eea;
            border-radius: 8px;
            cursor: pointer;
        }

        .tool-btn {
            padding: 10px 20px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        .tool-btn:hover {
            background: #667eea;
            color: white;
        }

        .tool-btn.active {
            background: #667eea;
            color: white;
        }

        .canvas-container {
            display: none;
            text-align: center;
            margin-top: 20px;
        }

        .canvas-container.active {
            display: block;
        }

        #coloringCanvas {
            border: 3px solid #667eea;
            border-radius: 10px;
            cursor: crosshair;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            background: white;
        }

        .action-buttons {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .action-btn {
            padding: 12px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-save {
            background: #10b981;
            color: white;
        }

        .btn-save:hover {
            background: #059669;
        }

        .btn-clear {
            background: #ef4444;
            color: white;
        }

        .btn-clear:hover {
            background: #dc2626;
        }

        .btn-new {
            background: #667eea;
            color: white;
        }

        .btn-new:hover {
            background: #764ba2;
        }

        .status {
            text-align: center;
            color: #10b981;
            font-weight: 600;
            margin-top: 10px;
            min-height: 20px;
        }

        .instructions {
            background: #f0f2ff;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .instructions h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .instructions ul {
            list-style-position: inside;
            color: #555;
        }

        .instructions li {
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üé® Ultimate Coloring Page Creator üñçÔ∏è</h1>
        <p>Upload your own photos OR generate beautiful patterns - works 100% offline!</p>
    </div>

    <div class="container">
        <div class="instructions">
            <h3>How to Use:</h3>
            <ul>
                <li><strong>Upload a Photo:</strong> Turn any photo (flowers, pets, landscapes) into line art you can color</li>
                <li><strong>Generate Random Page:</strong> Create beautiful patterns (mandalas, flowers, garden scenes) filled with shapes to color</li>
                <li>Choose your colors and brush size, then start coloring!</li>
                <li>Your work auto-saves every 30 seconds - never lose progress!</li>
                <li>Download your finished masterpiece when done</li>
            </ul>
        </div>

        <div class="upload-section" id="uploadSection">
            <h2>How would you like to create your coloring page?</h2>
            <p style="color: #666; margin-bottom: 30px;">Choose one of the options below:</p>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <div style="background: white; padding: 20px; border-radius: 10px; border: 2px solid #667eea;">
                    <h3 style="color: #667eea; margin-bottom: 15px;">üìÅ Upload a Photo</h3>
                    <p style="color: #666; margin-bottom: 15px; font-size: 0.9em;">Turn your own photos into line art - flowers, pets, landscapes, anything!</p>
                    <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                        Choose Photo
                    </button>
                    <input type="file" id="fileInput" accept="image/*">
                </div>
                
                <div style="background: white; padding: 20px; border-radius: 10px; border: 2px solid #764ba2;">
                    <h3 style="color: #764ba2; margin-bottom: 15px;">‚ú® Generate Random Page</h3>
                    <p style="color: #666; margin-bottom: 15px; font-size: 0.9em;">Create a page filled with random shapes and patterns to color!</p>
                    <button class="upload-btn" onclick="generateRandomPage()">
                        Generate Page
                    </button>
                </div>
            </div>
            
            <div id="generatorOptions" style="display: none; margin-top: 20px; padding: 20px; background: white; border-radius: 10px;">
                <h3 style="color: #764ba2; margin-bottom: 15px;">Choose a Pattern:</h3>
                <div style="display: flex; gap: 15px; flex-wrap: wrap; justify-content: center;">
                    <button class="tool-btn" onclick="generatePattern('mandala')">üå∏ Mandala</button>
                    <button class="tool-btn" onclick="generatePattern('geometric')">üî∑ Geometric</button>
                    <button class="tool-btn" onclick="generatePattern('flowers')">üå∫ Flowers</button>
                    <button class="tool-btn" onclick="generatePattern('abstract')">üé® Abstract Shapes</button>
                    <button class="tool-btn" onclick="generatePattern('garden')">üåø Garden Scene</button>
                </div>
            </div>
        </div>

        <div class="controls" id="controls">
            <div class="control-row">
                <div class="control-group">
                    <label>Detail Level:</label>
                    <input type="range" id="edgeThreshold" min="10" max="200" value="50">
                    <span id="thresholdValue">50</span>
                </div>
                <button class="tool-btn" onclick="reprocessImage()">üîÑ Update Line Art</button>
            </div>

            <div class="control-row">
                <div class="control-group">
                    <label>Brush Color:</label>
                    <input type="color" id="colorPicker" value="#FF6B6B">
                </div>
                <div class="control-group">
                    <label>Brush Size:</label>
                    <input type="range" id="brushSize" min="1" max="50" value="10">
                    <span id="brushSizeValue">10</span>
                </div>
                <button class="tool-btn" id="eraserBtn" onclick="toggleEraser()">üßπ Eraser</button>
                <button class="tool-btn" onclick="clearCanvas()">üóëÔ∏è Clear All Colors</button>
            </div>
        </div>

        <div class="canvas-container" id="canvasContainer">
            <canvas id="coloringCanvas"></canvas>
            <div class="action-buttons">
                <button class="action-btn btn-save" onclick="downloadImage()">üíæ Download Colored Page</button>
                <button class="action-btn btn-new" onclick="startOver()">üÜï Upload New Photo</button>
            </div>
            <div class="status" id="status"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('coloringCanvas');
        const ctx = canvas.getContext('2d');
        const fileInput = document.getElementById('fileInput');
        const colorPicker = document.getElementById('colorPicker');
        const brushSizeInput = document.getElementById('brushSize');
        const edgeThresholdInput = document.getElementById('edgeThreshold');
        const eraserBtn = document.getElementById('eraserBtn');
        const status = document.getElementById('status');

        let isDrawing = false;
        let currentColor = '#FF6B6B';
        let brushSize = 10;
        let isEraser = false;
        let originalImage = null;
        let lineArtImageData = null;
        let autoSaveInterval = null;
        let isGeneratedPage = false;

        // Update display values
        brushSizeInput.addEventListener('input', (e) => {
            brushSize = e.target.value;
            document.getElementById('brushSizeValue').textContent = brushSize;
        });

        edgeThresholdInput.addEventListener('input', (e) => {
            document.getElementById('thresholdValue').textContent = e.target.value;
        });

        colorPicker.addEventListener('input', (e) => {
            currentColor = e.target.value;
            isEraser = false;
            eraserBtn.classList.remove('active');
        });

        // Show generator options
        function generateRandomPage() {
            document.getElementById('generatorOptions').style.display = 'block';
        }

        // Pattern generation functions
        function generatePattern(type) {
            isGeneratedPage = true;
            canvas.width = 800;
            canvas.height = 800;
            
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;

            switch(type) {
                case 'mandala':
                    drawMandala();
                    break;
                case 'geometric':
                    drawGeometric();
                    break;
                case 'flowers':
                    drawFlowers();
                    break;
                case 'abstract':
                    drawAbstract();
                    break;
                case 'garden':
                    drawGarden();
                    break;
            }

            // Save as line art
            lineArtImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

            // Show controls and canvas
            document.getElementById('uploadSection').style.display = 'none';
            document.getElementById('controls').classList.add('active');
            document.getElementById('canvasContainer').classList.add('active');
            
            // Hide edge threshold control for generated pages
            document.getElementById('controls').querySelector('.control-row').style.display = 'none';

            startAutoSave();
        }

        function drawMandala() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const layers = 8;
            const petalsPerLayer = 12;

            for (let layer = 1; layer <= layers; layer++) {
                const radius = (layer / layers) * 350;
                
                // Draw circles
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.stroke();

                // Draw petals/rays
                for (let i = 0; i < petalsPerLayer; i++) {
                    const angle = (Math.PI * 2 / petalsPerLayer) * i;
                    const x1 = centerX + Math.cos(angle) * (radius - 20);
                    const y1 = centerY + Math.sin(angle) * (radius - 20);
                    const x2 = centerX + Math.cos(angle) * (radius + 20);
                    const y2 = centerY + Math.sin(angle) * (radius + 20);
                    
                    // Petal shape
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.quadraticCurveTo(
                        centerX + Math.cos(angle - 0.3) * radius,
                        centerY + Math.sin(angle - 0.3) * radius,
                        x2, y2
                    );
                    ctx.quadraticCurveTo(
                        centerX + Math.cos(angle + 0.3) * radius,
                        centerY + Math.sin(angle + 0.3) * radius,
                        centerX, centerY
                    );
                    ctx.stroke();
                }
            }

            // Center decoration
            ctx.beginPath();
            ctx.arc(centerX, centerY, 30, 0, Math.PI * 2);
            ctx.stroke();
        }

        function drawGeometric() {
            const gridSize = 8;
            const cellSize = canvas.width / gridSize;

            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const x = col * cellSize;
                    const y = row * cellSize;
                    const pattern = Math.floor(Math.random() * 4);

                    ctx.beginPath();
                    switch(pattern) {
                        case 0: // Diamond
                            ctx.moveTo(x + cellSize/2, y);
                            ctx.lineTo(x + cellSize, y + cellSize/2);
                            ctx.lineTo(x + cellSize/2, y + cellSize);
                            ctx.lineTo(x, y + cellSize/2);
                            ctx.closePath();
                            break;
                        case 1: // Circle
                            ctx.arc(x + cellSize/2, y + cellSize/2, cellSize/3, 0, Math.PI * 2);
                            break;
                        case 2: // Triangle
                            ctx.moveTo(x + cellSize/2, y);
                            ctx.lineTo(x + cellSize, y + cellSize);
                            ctx.lineTo(x, y + cellSize);
                            ctx.closePath();
                            break;
                        case 3: // Star
                            drawStar(x + cellSize/2, y + cellSize/2, 5, cellSize/3, cellSize/6);
                            break;
                    }
                    ctx.stroke();
                }
            }
        }

        function drawFlowers() {
            for (let i = 0; i < 25; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = 30 + Math.random() * 60;
                const petals = 5 + Math.floor(Math.random() * 4);

                // Stem
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.quadraticCurveTo(x - 10, y + 50, x - 5, y + 100);
                ctx.stroke();

                // Leaves
                ctx.beginPath();
                ctx.ellipse(x - 20, y + 50, 15, 8, -Math.PI / 4, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.ellipse(x + 10, y + 70, 15, 8, Math.PI / 4, 0, Math.PI * 2);
                ctx.stroke();

                // Flower
                for (let p = 0; p < petals; p++) {
                    const angle = (Math.PI * 2 / petals) * p;
                    const px = x + Math.cos(angle) * size;
                    const py = y + Math.sin(angle) * size;
                    
                    ctx.beginPath();
                    ctx.arc(px, py, size/2, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Center
                ctx.beginPath();
                ctx.arc(x, y, size/3, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        function drawAbstract() {
            // Random organic shapes
            for (let i = 0; i < 30; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const points = 5 + Math.floor(Math.random() * 8);
                const size = 40 + Math.random() * 80;

                ctx.beginPath();
                for (let p = 0; p <= points; p++) {
                    const angle = (Math.PI * 2 / points) * p;
                    const radius = size * (0.7 + Math.random() * 0.3);
                    const px = x + Math.cos(angle) * radius;
                    const py = y + Math.sin(angle) * radius;
                    
                    if (p === 0) {
                        ctx.moveTo(px, py);
                    } else {
                        const prevAngle = (Math.PI * 2 / points) * (p - 1);
                        const prevPx = x + Math.cos(prevAngle) * radius;
                        const prevPy = y + Math.sin(prevAngle) * radius;
                        
                        ctx.quadraticCurveTo(
                            (prevPx + px) / 2 + (Math.random() - 0.5) * 20,
                            (prevPy + py) / 2 + (Math.random() - 0.5) * 20,
                            px, py
                        );
                    }
                }
                ctx.closePath();
                ctx.stroke();
            }
        }

        function drawGarden() {
            // Sky elements
            ctx.beginPath();
            ctx.arc(650, 150, 60, 0, Math.PI * 2);
            ctx.stroke(); // Sun

            // Clouds
            for (let i = 0; i < 3; i++) {
                const x = 100 + i * 250;
                const y = 100 + Math.random() * 50;
                drawCloud(x, y);
            }

            // Ground
            ctx.beginPath();
            ctx.moveTo(0, 500);
            ctx.quadraticCurveTo(200, 480, 400, 500);
            ctx.quadraticCurveTo(600, 520, 800, 500);
            ctx.lineTo(800, 800);
            ctx.lineTo(0, 800);
            ctx.closePath();
            ctx.stroke();

            // Trees
            for (let i = 0; i < 3; i++) {
                const x = 150 + i * 250;
                drawTree(x, 450);
            }

            // Flowers in foreground
            for (let i = 0; i < 15; i++) {
                const x = Math.random() * canvas.width;
                const y = 500 + Math.random() * 250;
                drawSimpleFlower(x, y);
            }

            // Butterflies
            for (let i = 0; i < 3; i++) {
                const x = 100 + Math.random() * 600;
                const y = 200 + Math.random() * 200;
                drawButterfly(x, y);
            }
        }

        function drawStar(cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI / 2 * 3;
            let x = cx;
            let y = cy;
            const step = Math.PI / spikes;

            ctx.moveTo(cx, cy - outerRadius);
            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius;
                y = cy + Math.sin(rot) * outerRadius;
                ctx.lineTo(x, y);
                rot += step;

                x = cx + Math.cos(rot) * innerRadius;
                y = cy + Math.sin(rot) * innerRadius;
                ctx.lineTo(x, y);
                rot += step;
            }
            ctx.lineTo(cx, cy - outerRadius);
        }

        function drawCloud(x, y) {
            ctx.beginPath();
            ctx.arc(x, y, 30, 0, Math.PI * 2);
            ctx.arc(x + 25, y - 10, 25, 0, Math.PI * 2);
            ctx.arc(x + 50, y, 30, 0, Math.PI * 2);
            ctx.stroke();
        }

        function drawTree(x, y) {
            // Trunk
            ctx.beginPath();
            ctx.rect(x - 15, y, 30, 80);
            ctx.stroke();

            // Foliage
            ctx.beginPath();
            ctx.arc(x, y - 20, 60, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(x - 30, y + 10, 50, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(x + 30, y + 10, 50, 0, Math.PI * 2);
            ctx.stroke();
        }

        function drawSimpleFlower(x, y) {
            // Stem
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x, y + 40);
            ctx.stroke();

            // Petals
            for (let i = 0; i < 5; i++) {
                const angle = (Math.PI * 2 / 5) * i;
                const px = x + Math.cos(angle) * 15;
                const py = y + Math.sin(angle) * 15;
                ctx.beginPath();
                ctx.arc(px, py, 10, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Center
            ctx.beginPath();
            ctx.arc(x, y, 8, 0, Math.PI * 2);
            ctx.stroke();
        }

        function drawButterfly(x, y) {
            // Body
            ctx.beginPath();
            ctx.ellipse(x, y, 3, 15, 0, 0, Math.PI * 2);
            ctx.stroke();

            // Wings
            ctx.beginPath();
            ctx.ellipse(x - 15, y - 5, 12, 18, -Math.PI / 6, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.ellipse(x + 15, y - 5, 12, 18, Math.PI / 6, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.ellipse(x - 15, y + 5, 10, 15, Math.PI / 6, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.ellipse(x + 15, y + 5, 10, 15, -Math.PI / 6, 0, Math.PI * 2);
            ctx.stroke();
        }

        // File upload handler
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        originalImage = img;
                        processImage(img);
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        function processImage(img) {
            // Set canvas size to image size (max 800px)
            const maxSize = 800;
            let width = img.width;
            let height = img.height;

            if (width > height && width > maxSize) {
                height = (height / width) * maxSize;
                width = maxSize;
            } else if (height > maxSize) {
                width = (width / height) * maxSize;
                height = maxSize;
            }

            canvas.width = width;
            canvas.height = height;

            // Draw and convert to line art
            ctx.drawImage(img, 0, 0, width, height);
            convertToLineArt();

            // Show controls and canvas
            document.getElementById('uploadSection').style.display = 'none';
            document.getElementById('controls').classList.add('active');
            document.getElementById('canvasContainer').classList.add('active');

            // Start autosave
            startAutoSave();

            // Try to load previous work
            loadAutoSave();
        }

        function convertToLineArt() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Convert to grayscale
            for (let i = 0; i < data.length; i += 4) {
                const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                data[i] = gray;
                data[i + 1] = gray;
                data[i + 2] = gray;
            }

            // Edge detection (simple Sobel operator)
            const edges = new Uint8ClampedArray(data.length);
            const threshold = parseInt(edgeThresholdInput.value);
            const width = canvas.width;

            for (let y = 1; y < canvas.height - 1; y++) {
                for (let x = 1; x < canvas.width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    
                    // Sobel kernels
                    const gx = 
                        -data[idx - width * 4 - 4] + data[idx - width * 4 + 4] +
                        -2 * data[idx - 4] + 2 * data[idx + 4] +
                        -data[idx + width * 4 - 4] + data[idx + width * 4 + 4];
                    
                    const gy = 
                        -data[idx - width * 4 - 4] - 2 * data[idx - width * 4] - data[idx - width * 4 + 4] +
                        data[idx + width * 4 - 4] + 2 * data[idx + width * 4] + data[idx + width * 4 + 4];
                    
                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    
                    const value = magnitude > threshold ? 0 : 255;
                    edges[idx] = value;
                    edges[idx + 1] = value;
                    edges[idx + 2] = value;
                    edges[idx + 3] = 255;
                }
            }

            // Store the line art
            lineArtImageData = new ImageData(edges, canvas.width, canvas.height);
            ctx.putImageData(lineArtImageData, 0, 0);
        }

        function reprocessImage() {
            if (originalImage) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);
                convertToLineArt();
                showStatus('Line art updated!');
            }
        }

        function toggleEraser() {
            isEraser = !isEraser;
            eraserBtn.classList.toggle('active');
        }

        // Drawing functions
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            isDrawing = true;
            drawAt(x, y);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isDrawing) return;
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            drawAt(x, y);
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            stopDrawing();
        });

        function startDrawing(e) {
            isDrawing = true;
            draw(e);
        }

        function draw(e) {
            if (!isDrawing) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            drawAt(x, y);
        }

        function drawAt(x, y) {
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = brushSize;

            if (isEraser) {
                ctx.globalCompositeOperation = 'destination-out';
            } else {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = currentColor;
            }

            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, y);
        }

        function stopDrawing() {
            isDrawing = false;
            ctx.beginPath();
            ctx.globalCompositeOperation = 'source-over';
        }

        function clearCanvas() {
            if (confirm('Clear all your coloring and start fresh?')) {
                ctx.putImageData(lineArtImageData, 0, 0);
                showStatus('Canvas cleared!');
            }
        }

        function downloadImage() {
            const link = document.createElement('a');
            link.download = 'my-colored-page.png';
            link.href = canvas.toDataURL();
            link.click();
            showStatus('Image downloaded!');
        }

        function startOver() {
            if (confirm('Start over with a new page? (Your current work will be lost)')) {
                clearAutoSave();
                isGeneratedPage = false;
                document.getElementById('uploadSection').style.display = 'block';
                document.getElementById('generatorOptions').style.display = 'none';
                document.getElementById('controls').classList.remove('active');
                document.getElementById('controls').querySelector('.control-row').style.display = 'flex';
                document.getElementById('canvasContainer').classList.remove('active');
                fileInput.value = '';
            }
        }

        // Auto-save functionality
        function startAutoSave() {
            clearAutoSave();
            autoSaveInterval = setInterval(() => {
                localStorage.setItem('coloringPage_autosave', canvas.toDataURL());
                localStorage.setItem('coloringPage_timestamp', new Date().toISOString());
                showStatus('‚úì Auto-saved', 2000);
            }, 30000); // Every 30 seconds
        }

        function loadAutoSave() {
            const saved = localStorage.getItem('coloringPage_autosave');
            if (saved && confirm('Found previous work! Would you like to restore it?')) {
                const img = new Image();
                img.onload = () => {
                    ctx.drawImage(img, 0, 0);
                    showStatus('Previous work restored!');
                };
                img.src = saved;
            }
        }

        function clearAutoSave() {
            if (autoSaveInterval) {
                clearInterval(autoSaveInterval);
            }
            localStorage.removeItem('coloringPage_autosave');
            localStorage.removeItem('coloringPage_timestamp');
        }

        function showStatus(message, duration = 3000) {
            status.textContent = message;
            setTimeout(() => {
                status.textContent = '';
            }, duration);
        }

        // Save before leaving
        window.addEventListener('beforeunload', () => {
            if (canvas.width > 0) {
                localStorage.setItem('coloringPage_autosave', canvas.toDataURL());
            }
        });
    </script>
</body>
</html>